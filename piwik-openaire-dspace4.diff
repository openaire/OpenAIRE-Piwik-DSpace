diff --git a/dspace/config/launcher.xml b/dspace/config/launcher.xml
index 6ad206398..ccfe4049f 100644
--- a/dspace/config/launcher.xml
+++ b/dspace/config/launcher.xml
@@ -418,5 +418,28 @@
             <class>org.dspace.app.util.Version</class>
         </step>
     </command>
-
+    <command>
+        <name>resend-to-matomo</name>
+        <description>Create Matomo DB for Missing Usage Events</description>
+        <arguments>-create</arguments>
+        <step>
+            <class>com.openaire.piwik.tracker.OpenAirePiwikTrackerUnreportedDB</class>
+        </step>
+    </command>
+    <command>
+        <name>resend-to-matomo</name>
+        <description>Retry sending all Missing Usage Events to Matomo</description>
+        <arguments>-retry</arguments>
+        <step>
+            <class>com.openaire.piwik.tracker.OpenAirePiwikTrackerUnreportedDB</class>
+        </step>
+    </command>
+    <command>
+        <name>resend-to-matomo</name>
+        <description>Delete Usage Events Sent to Matomo</description>
+        <arguments>-delete</arguments>
+        <step>
+            <class>com.openaire.piwik.tracker.OpenAirePiwikTrackerUnreportedDB</class>
+        </step>
+    </command>
 </commands>
diff --git a/dspace/config/modules/oapiwik.cfg b/dspace/config/modules/oapiwik.cfg
new file mode 100755
index 000000000..489e3c261
--- /dev/null
+++ b/dspace/config/modules/oapiwik.cfg
@@ -0,0 +1,16 @@
+
+
+#------------------------#
+# OpenAIRE Piwik Tracker #
+#------------------------#
+piwik.trackerURL = https://analytics.openaire.eu/piwik.php
+piwik.siteID = 1
+piwik.tokenAuth=32846584f571be9b57488bf4088f30ea
+#piwik.ipanonymizationbytes=2
+piwik.enabled = true
+
+# Flag whether failed reports of views should be stored in a database to resend them later
+piwik.retry = true
+
+# Location of the SQLite DB on the file system is [dspace]/oapiwik.piwik.matomoDbLocation
+piwik.matomoDbLocation = var/Matomo.db
diff --git a/dspace/config/spring/jspui/openaire-piwik-xmlui.xml b/dspace/config/spring/jspui/openaire-piwik-xmlui.xml
new file mode 100755
index 000000000..d2c2e7ee6
--- /dev/null
+++ b/dspace/config/spring/jspui/openaire-piwik-xmlui.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<beans
+    xmlns="http://www.springframework.org/schema/beans"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xmlns:util="http://www.springframework.org/schema/util"
+    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
+                           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.0.xsd">
+
+    <bean id="piwikOpenAire" class="com.openaire.piwik.tracker.OpenAirePiwikTracker" lazy-init="true">
+    </bean>
+
+</beans>
diff --git a/dspace/config/spring/xmlui/openaire-piwik-xmlui.xml b/dspace/config/spring/xmlui/openaire-piwik-xmlui.xml
new file mode 100755
index 000000000..d2c2e7ee6
--- /dev/null
+++ b/dspace/config/spring/xmlui/openaire-piwik-xmlui.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<beans
+    xmlns="http://www.springframework.org/schema/beans"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xmlns:util="http://www.springframework.org/schema/util"
+    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
+                           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.0.xsd">
+
+    <bean id="piwikOpenAire" class="com.openaire.piwik.tracker.OpenAirePiwikTracker" lazy-init="true">
+    </bean>
+
+</beans>
diff --git a/dspace/modules/additions/pom.xml b/dspace/modules/additions/pom.xml
index 7953637bd..e0f8c4c04 100644
--- a/dspace/modules/additions/pom.xml
+++ b/dspace/modules/additions/pom.xml
@@ -96,7 +96,12 @@
             </exclusion>
          </exclusions>
       </dependency>
-
+      <dependency>
+         <groupId>com.openaire</groupId>
+         <artifactId>openaire-piwik-api</artifactId>
+         <version>1.0.0</version>
+         <type>jar</type>
+      </dependency>
    </dependencies>
 
 </project>
diff --git a/dspace/modules/jspui/pom.xml b/dspace/modules/jspui/pom.xml
index be68bff69..910241579 100644
--- a/dspace/modules/jspui/pom.xml
+++ b/dspace/modules/jspui/pom.xml
@@ -85,7 +85,14 @@
             <groupId>org.dspace.modules</groupId>
             <artifactId>additions</artifactId>
         </dependency>
-
+       <!-- OpenAire Piwik Tracker  -->
+        <dependency>
+            <groupId>com.openaire</groupId>
+            <artifactId>openaire-piwik-api</artifactId>
+            <version>1.0.0</version>
+            <type>jar</type>
+        </dependency>
+        
         <dependency>
             <groupId>org.dspace</groupId>
             <artifactId>dspace-jspui</artifactId>
diff --git a/dspace/modules/openaire-piwik/openaire-piwik-api/pom.xml b/dspace/modules/openaire-piwik/openaire-piwik-api/pom.xml
new file mode 100755
index 000000000..15e752ece
--- /dev/null
+++ b/dspace/modules/openaire-piwik/openaire-piwik-api/pom.xml
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>com.openaire</groupId>
+        <artifactId>openaire-piwik</artifactId>
+        <version>1.0.0</version>
+    </parent>
+
+    <groupId>com.openaire</groupId>
+    <artifactId>openaire-piwik-api</artifactId>
+    <version>1.0.0</version>
+    <packaging>jar</packaging>
+    <name>OpenAIRE Piwik Tracker API</name>
+    <url>openaire.eu</url>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.dspace</groupId>
+            <artifactId>dspace-api</artifactId>
+
+        </dependency>
+
+        <dependency>
+            <groupId>javax.servlet</groupId>
+            <artifactId>servlet-api</artifactId>
+            <version>2.3</version>
+            <scope>provided</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.httpcomponents</groupId>
+            <artifactId>httpasyncclient</artifactId>
+            <version>4.0.2</version>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.httpcomponents</groupId>
+            <artifactId>httpcore</artifactId>
+            <version>4.4.1</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.httpcomponents</groupId>
+            <artifactId>httpclient</artifactId>
+            <version>4.4.1</version>
+        </dependency>
+        <!-- https://mvnrepository.com/artifact/org.xerial/sqlite-jdbc -->
+        <dependency>
+            <groupId>org.xerial</groupId>
+            <artifactId>sqlite-jdbc</artifactId>
+            <version>3.21.0.1</version>
+        </dependency>
+    </dependencies>
+</project>
diff --git a/dspace/modules/openaire-piwik/openaire-piwik-api/src/main/java/com/openaire/piwik/tracker/AbstractUsageEventListener.java b/dspace/modules/openaire-piwik/openaire-piwik-api/src/main/java/com/openaire/piwik/tracker/AbstractUsageEventListener.java
new file mode 100755
index 000000000..c6a6db7bb
--- /dev/null
+++ b/dspace/modules/openaire-piwik/openaire-piwik-api/src/main/java/com/openaire/piwik/tracker/AbstractUsageEventListener.java
@@ -0,0 +1,70 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package com.openaire.piwik.tracker;
+
+import org.dspace.services.EventService;
+import org.dspace.services.model.EventListener;
+import org.springframework.beans.BeansException;
+import org.springframework.beans.factory.config.BeanPostProcessor;
+
+/**
+ * AbstractUsageEventListener is used as the base class for listening events running
+ * in the EventService.
+ *
+ * @author Mark Diggory (mdiggory at atmire.com)
+ * @version $Revision: $
+ */
+public abstract class AbstractUsageEventListener implements EventListener, BeanPostProcessor {
+
+	public AbstractUsageEventListener() {
+		super();
+	}
+
+    @Override
+    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
+        return bean;
+    }
+
+    @Override
+    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
+        if(beanName.equals("org.dspace.services.EventService"))
+        {
+            setEventService((EventService) bean);
+        }
+        return bean;
+	}
+
+	/**
+	 * Empty String[] flags to have Listener
+	 * consume any event name prefixes.
+	 */
+	public String[] getEventNamePrefixes() {
+		return new String[0];
+	}
+
+	/**
+	 * Currently consumes events generated for
+	 * all resources.
+	 */
+	public String getResourcePrefix() {
+		return null;
+	}
+
+	public void setEventService(EventService service) {
+		if(service != null)
+        {
+            service.registerEventListener(this);
+        }
+		else
+        {
+            throw new IllegalStateException("EventService handed to Listener cannot be null");
+        }
+
+	}
+
+}
diff --git a/dspace/modules/openaire-piwik/openaire-piwik-api/src/main/java/com/openaire/piwik/tracker/OpenAirePiwikTracker.java b/dspace/modules/openaire-piwik/openaire-piwik-api/src/main/java/com/openaire/piwik/tracker/OpenAirePiwikTracker.java
new file mode 100755
index 000000000..132b079d4
--- /dev/null
+++ b/dspace/modules/openaire-piwik/openaire-piwik-api/src/main/java/com/openaire/piwik/tracker/OpenAirePiwikTracker.java
@@ -0,0 +1,433 @@
+/*
+ * OpenAirePiwikTracker.java
+ *
+ * Version: 0.2
+ * Date: 2018-05-20
+ * Initial version @mire.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * - Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * - Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ */
+package com.openaire.piwik.tracker;
+
+import java.io.IOException;
+import java.net.Inet6Address;
+import java.net.InetAddress;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.UnknownHostException;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+
+import javax.servlet.http.HttpServletRequest;
+
+import org.apache.commons.lang.StringUtils;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.client.config.RequestConfig;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.utils.URIBuilder;
+import org.apache.http.concurrent.FutureCallback;
+import org.apache.http.impl.nio.client.CloseableHttpAsyncClient;
+import org.apache.http.impl.nio.client.HttpAsyncClients;
+import org.apache.http.impl.nio.conn.PoolingNHttpClientConnectionManager;
+import org.apache.http.impl.nio.reactor.DefaultConnectingIOReactor;
+import org.apache.log4j.Logger;
+import org.dspace.app.util.Util;
+import org.dspace.core.ConfigurationManager;
+import org.dspace.content.*;
+import org.dspace.core.LogManager;
+import org.dspace.core.Constants;
+import org.dspace.services.model.Event;
+import org.dspace.usage.UsageEvent;
+
+import com.google.gson.Gson;
+
+/**
+ * User: dpie (dpierrakos at gmail.com) Date: Time:
+ */
+public class OpenAirePiwikTracker extends AbstractUsageEventListener
+{
+    /* Log4j logger */
+    private static Logger log = Logger.getLogger(OpenAirePiwikTracker.class);
+
+    // Base URl of the Piwik platform
+    private String piwikbaseUrl;
+
+    // Piwik Site ID
+    private String piwikSiteID;
+
+    // Piwik IP Anonumization Bytes
+    private int piwikIPAnonymizationBytes;
+
+    // Piwik Site Authentication Token
+    private String piwikTokenAuth;
+
+    // Flag if Piwik is enabled for current installation. Might be disabled for
+    // test instances e.g..
+    private boolean piwikEnabled;
+
+    // Flag if mising requests are stored in local DB for retry
+    private boolean piwikRetry;
+
+    // Flag if a proxy is in front of the DSpace instance
+    private boolean useProxies;
+
+    // The URL of this DSpace instance
+    private String dspaceURL;
+
+    // The host name of this DSpace instance
+    private String dspaceHostName;
+
+    // Async http client to prevent waiting for piwik server
+   private CloseableHttpAsyncClient httpClient;
+
+    // Pooling connection manager for httpClient
+    private PoolingNHttpClientConnectionManager connectionManager;
+
+    // The time out for a single connection if piwik is slow or unreachable.
+    private static final int CONNECTION_TIMEOUT = 5 * 1000;
+
+    // The number of connections per route
+    private static final int NUMBER_OF_CONNECTIONS_PER_ROUTE = 100;
+
+    // If there are more than MAX_NUMBER_OF_PENDING_CONNECTIONS waiting to be
+    // served events wont be send to Piwik
+    private static final int MAX_NUMBER_OF_PENDING_CONNECTIONS = 10;
+
+    /**
+     * Constructor to initialize the HTTP Client. We only need one per instance
+     * as it is able to handle multiple requests by multiple Threads at once.
+     * 
+     */
+    public OpenAirePiwikTracker()
+    {
+        // init the httpClient with custom number of connections and timeout
+
+       // httpClient = HttpAsyncClients.createDefault();
+
+        //httpClient.start();
+
+     try
+        {
+            RequestConfig requestConfig = RequestConfig.custom()
+                    .setConnectTimeout(CONNECTION_TIMEOUT)
+                    .setSocketTimeout(CONNECTION_TIMEOUT).build();
+            DefaultConnectingIOReactor ioreactor;
+            ioreactor = new DefaultConnectingIOReactor();
+            connectionManager = new PoolingNHttpClientConnectionManager(
+                    ioreactor);
+            connectionManager
+                    .setDefaultMaxPerRoute(NUMBER_OF_CONNECTIONS_PER_ROUTE);
+            httpClient = HttpAsyncClients.custom()
+                    .setDefaultRequestConfig(requestConfig)
+                    .setConnectionManager(connectionManager).build();
+
+            httpClient.start();
+
+        }
+        catch (Exception e)
+        {
+            log.error(
+                    "Piwik Tracker couldn't be initialized. There will be no tracking until server restart.",
+                    e);
+            httpClient = null;
+        }
+}
+
+
+    /**
+     * Read the Piwik configuration options
+     */
+    private void readConfiguration()
+    {
+        // Piwik variables
+        piwikEnabled = ConfigurationManager.getBooleanProperty("oapiwik", "piwik.enabled");
+        piwikbaseUrl = ConfigurationManager.getProperty("oapiwik", "piwik.trackerURL");
+        piwikSiteID = ConfigurationManager.getProperty("oapiwik", "piwik.siteID");
+        piwikTokenAuth = ConfigurationManager.getProperty("oapiwik","piwik.tokenAuth");
+
+        piwikIPAnonymizationBytes = ConfigurationManager.getIntProperty("oapiwik","piwik.ipanonymizationbytes");
+
+        piwikRetry = ConfigurationManager.getBooleanProperty("oapiwik", "piwik.retry");
+
+        // DSpace variables
+        useProxies =  ConfigurationManager.getBooleanProperty("useProxies");
+
+        dspaceURL = ConfigurationManager.getProperty("dspace.url");
+        dspaceHostName = ConfigurationManager.getProperty("dspace.hostname");
+
+    }
+
+    @Override
+    public void receiveEvent(final Event event)
+    {
+
+        if (!(event instanceof UsageEvent))
+        {
+            return;
+        }
+
+        try
+        {
+            this.readConfiguration();
+            if (!piwikEnabled || httpClient == null)
+            {
+                return;
+            }
+
+            if (connectionManager.getTotalStats()
+                    .getPending() >= MAX_NUMBER_OF_PENDING_CONNECTIONS)
+            {
+                log.error(
+                        "Event could not be sent to Piwik server due to insufficient available connections");
+                return;
+            }
+
+            log.debug("Usage event received " + event.getName());
+
+            UsageEvent ue = (UsageEvent) event;
+            if (ue.getAction() == UsageEvent.Action.VIEW)
+            {
+                // Item Download Case
+                if (ue.getObject().getType() == Constants.BITSTREAM)
+                {
+                    Bitstream bitstream = (Bitstream) ue.getObject();
+                    if (bitstream.getBundles().length > 0)
+                    {
+                        Bundle bundle = bitstream.getBundles()[0];
+                        if (bundle.getItems().length > 0)
+                        {
+                            Item item = bundle.getItems()[0];
+                            this.logEvent(item, bitstream, ue.getRequest());
+                        }
+                    }
+                }
+                // Item View Case
+                if (ue.getObject().getType() == Constants.ITEM)
+                {
+                    Item item = (Item) ue.getObject();
+                    this.logEvent(item, null, ue.getRequest());
+                }
+            }
+
+        }
+        catch (Exception e)
+        {
+            log.error(e.getMessage());
+        }
+    }
+
+    /**
+     * Builds the URI to send the event to the configured Piwik instance and
+     * sends the request.
+     */
+    private void logEvent(final Item item, final Bitstream bitstream,
+        final HttpServletRequest request)
+    throws IOException, URISyntaxException
+    {
+        URIBuilder builder = new URIBuilder();
+        builder.setPath(piwikbaseUrl);
+        builder.addParameter("idsite", piwikSiteID);
+        builder.addParameter("cip", this.getIPAddress(request));
+        builder.addParameter("rec", "1");
+        builder.addParameter("token_auth", piwikTokenAuth);
+        builder.addParameter("action_name", item.getName());
+
+        // Agent Information
+        String agent = StringUtils
+        .defaultIfBlank(request.getHeader("USER-AGENT"), "");
+        builder.addParameter("ua", agent);
+
+        // Referer Information
+        String urlref = StringUtils.defaultIfBlank(request.getHeader("referer"),
+            "");
+        builder.addParameter("urlref", urlref);
+
+        // Country information in case of IPAnonymization
+        if (piwikIPAnonymizationBytes > 0 && piwikIPAnonymizationBytes < 4)
+        {
+            String country = "";
+            try
+            {
+                Locale locale = request.getLocale();
+                country = locale.getCountry();
+            }
+            catch (Exception e)
+            {
+                log.error("Cannot get locale", e);
+            }
+            builder.addParameter("country", country);
+        }
+
+        if (bitstream != null)
+        {
+            // Bitstream information in case of download event
+            StringBuffer sb = new StringBuffer(dspaceURL);
+            sb.append("/bitstream/handle/").append(item.getHandle())
+            .append("/");
+            sb.append(bitstream.getName());
+            builder.addParameter("url", sb.toString());
+            builder.addParameter("download", sb.toString());
+
+        }
+        else
+        {
+            // Item information in case of Item view event
+            builder.addParameter("url",
+                dspaceURL + "/handle/" + item.getHandle());
+        }
+
+        // Piwik Custom Variable for OAI-PMH ID tracking
+        Gson gson = new Gson();
+        Map<String, String[]> jsonPiwikCustomVars = new HashMap();
+        String[] oaipmhID = new String[] { "oaipmhID",
+        "oai:" + dspaceHostName + ":" + item.getHandle() };
+        jsonPiwikCustomVars.put("1", oaipmhID);
+        builder.addParameter("cvar", gson.toJson(jsonPiwikCustomVars));
+
+        this.sendRequest(builder.build());
+    }
+
+    /**
+     * Get the IP-Address from the given request. Handles cases where a Proxy is
+     * involved and IP-Address anonymization. Not yet working with IPv6
+     * 
+     * @param request
+     * @return
+     * @throws UnknownHostException
+     */
+    private String getIPAddress(final HttpServletRequest request)
+    throws UnknownHostException
+    {
+        String clientIP = request.getRemoteAddr();
+        if (useProxies && request.getHeader("X-Forwarded-For") != null)
+        {
+            /* This header is a comma delimited list */
+            for (String xfip : request.getHeader("X-Forwarded-For").split(","))
+            {
+                /*
+                 * proxy itself will sometime populate this header with the same
+                 * value in remote address. ordering in spec is vague, we'll
+                 * just take the last not equal to the proxy
+                 */
+                if (!request.getHeader("X-Forwarded-For").contains(clientIP))
+                {
+                    clientIP = xfip.trim();
+                }
+            }
+        }
+
+        // IP anonymization case
+
+        if (piwikIPAnonymizationBytes > 0 && piwikIPAnonymizationBytes < 4)
+        {
+
+            // Check IPv4 or IPv6
+            InetAddress ipadress = InetAddress.getByName(clientIP);
+            if (ipadress instanceof Inet6Address)
+            {
+                clientIP = "0.0.0.0";
+            }
+            else
+            {
+                switch (piwikIPAnonymizationBytes)
+                {
+                    case 1:
+                    clientIP = clientIP.substring(0,
+                        StringUtils.ordinalIndexOf(clientIP, ".", 3))
+                    + ".0";
+                    break;
+                    case 2:
+                    clientIP = clientIP.substring(0,
+                        StringUtils.ordinalIndexOf(clientIP, ".", 2))
+                    + ".0.0";
+                    break;
+                    case 3:
+                    clientIP = clientIP.substring(0,
+                        StringUtils.ordinalIndexOf(clientIP, ".", 1))
+                    + ".0.0.0";
+                    break;
+                    default:
+                    throw new IllegalArgumentException(
+                        "Invalid IP bytes: " + piwikIPAnonymizationBytes);
+                }
+            }
+        }
+
+        return clientIP;
+    }
+
+    /**
+     * Send the request to the given URI. Ignores the result except
+     * for a status code check.
+     */
+      private void sendRequest(final URI uri)
+    {
+        final HttpGet request = new HttpGet(uri);
+        httpClient.execute(request, new FutureCallback<HttpResponse>()
+        {
+            @Override
+            public void completed(final HttpResponse response)
+            {
+                if (response.getStatusLine()
+                        .getStatusCode() == HttpStatus.SC_OK)
+                {
+                    log.info("Sent usage event to piwik");
+                }
+                else
+                {
+                    log.error("Error sending reqeust to Piwik." + " -> "
+                            + response.getStatusLine());
+                }
+            }
+
+            @Override
+            public void failed(final Exception ex)
+            {
+                log.error("Error sending usage event to Piwik", ex);
+                try
+                {
+                    if (piwikRetry)
+                    {
+                        OpenAirePiwikTrackerUnreported unreportedReq = new OpenAirePiwikTrackerUnreported();
+                        unreportedReq.storeRequest(uri.toString());
+                        log.info("Missing request stored to local DB");
+                    }
+                }
+                catch (Exception e)
+                {
+                    log.error("Error storing unreported request");
+                }
+            }
+
+            @Override
+            public void cancelled()
+            {
+                log.info("Request cancelled");
+            }
+
+        });
+    }
+
+}
diff --git a/dspace/modules/openaire-piwik/openaire-piwik-api/src/main/java/com/openaire/piwik/tracker/OpenAirePiwikTrackerUnreported.java b/dspace/modules/openaire-piwik/openaire-piwik-api/src/main/java/com/openaire/piwik/tracker/OpenAirePiwikTrackerUnreported.java
new file mode 100755
index 000000000..7e757c41c
--- /dev/null
+++ b/dspace/modules/openaire-piwik/openaire-piwik-api/src/main/java/com/openaire/piwik/tracker/OpenAirePiwikTrackerUnreported.java
@@ -0,0 +1,78 @@
+/*
+ * OpenAirePiwikTrackerUnreported.java
+ *
+ * Version: 0.1
+ * Date: 2018-05-20
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * - Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * - Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ */
+package com.openaire.piwik.tracker;
+
+import java.sql.Connection;
+import java.sql.DriverManager;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.sql.Timestamp;
+import java.util.Calendar;
+
+import org.apache.log4j.Logger;
+
+/**
+ * User: dpie (dpierrakos at gmail.com) Date: Time:
+ */
+public class OpenAirePiwikTrackerUnreported {
+
+    private static Logger log = Logger
+                                .getLogger(OpenAirePiwikTrackerUnreported.class);
+
+    public OpenAirePiwikTrackerUnreported() {
+        try {
+            // The JDBC driver loading doesn't work for webapps without this.
+            // http://tomcat.apache.org/tomcat-8.0-doc/jndi-datasource-examples-howto.html#DriverManager,_the_service_provider_mechanism_and_memory_leaks
+            Class.forName("org.sqlite.JDBC");
+        } catch (ClassNotFoundException e) {
+            log.error("Could not load sqlite JDBC driver");
+        }
+    }
+
+    public void storeRequest(String requestLost) throws Exception {
+
+        try {
+            Connection conn = DriverManager.getConnection(
+                                  OpenAirePiwikTrackerUnreportedDB.getMatomoDatabaseUrl());
+            Statement stmt = conn.createStatement();
+
+            log.info("Connected to Matomo DB...");
+
+            Timestamp currentTimestamp = new java.sql.Timestamp(
+                Calendar.getInstance().getTime().getTime());
+            String sqlInsertMissingRequestsToDB = "INSERT INTO MissingInformation (time_req,url,isSend) "
+                                                  + "VALUES ('" + currentTimestamp + "','" + requestLost
+                                                  + "',0);";
+
+            stmt.execute(sqlInsertMissingRequestsToDB);
+        } catch (SQLException e) {
+            log.error(e.getMessage());
+        }
+    }
+}
\ No newline at end of file
diff --git a/dspace/modules/openaire-piwik/openaire-piwik-api/src/main/java/com/openaire/piwik/tracker/OpenAirePiwikTrackerUnreportedDB.java b/dspace/modules/openaire-piwik/openaire-piwik-api/src/main/java/com/openaire/piwik/tracker/OpenAirePiwikTrackerUnreportedDB.java
new file mode 100755
index 000000000..dbf96df14
--- /dev/null
+++ b/dspace/modules/openaire-piwik/openaire-piwik-api/src/main/java/com/openaire/piwik/tracker/OpenAirePiwikTrackerUnreportedDB.java
@@ -0,0 +1,135 @@
+/*
+ * OpenAirePiwikTrackerUnreportedDB.java
+ *
+ * Version: 0.1
+ * Date: 2018-05-20
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * - Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * - Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ */
+package com.openaire.piwik.tracker;
+
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.net.URLEncoder;
+import java.nio.charset.StandardCharsets;
+import java.sql.Connection;
+import java.sql.DriverManager;
+import java.sql.ResultSet;
+import java.sql.Statement;
+import java.util.HashMap;
+import java.util.Map;
+import org.dspace.core.ConfigurationManager;
+
+/**
+ * User: dpie (dpierrakos at gmail.com) Date: Time:
+**/
+public class OpenAirePiwikTrackerUnreportedDB {
+
+    public static String getMatomoDatabaseUrl() {
+        String dspaceDir = ConfigurationManager.getProperty("dspace.dir");
+
+        String matomoDbLocation = ConfigurationManager.getProperty("oapiwik", "piwik.matomoDbLocation");
+
+        String connectionStringMatomoDB = "jdbc:sqlite:" + dspaceDir + "/"
+                                          + matomoDbLocation;
+
+        return connectionStringMatomoDB;
+    }
+
+    public static void main(String[] args) throws Exception {
+
+        String argument = args[0];
+        if (!("-create".equals(argument)) && !("-retry".equals(argument))
+                && !("-delete".equals(argument))) {
+            System.out.println("Usage: dspace.dir/bin/dspace -create or -retry or -delete");
+            return;
+        }
+
+        try {
+            Connection conn = DriverManager
+                              .getConnection(getMatomoDatabaseUrl());
+            Statement stmt = conn.createStatement();
+
+            System.out.println("Connected to Matomo DB...");
+            if (argument.equals("-create")) {
+
+                String sqlCreate = "CREATE TABLE IF NOT EXISTS MissingInformation (time_req TEXT PRIMARY KEY, url TEXT NOT NULL, isSend INTEGER NOT NULL);";
+                stmt.executeUpdate(sqlCreate);
+            } else if (argument.equals("-retry")) {
+
+                try {
+
+                    ResultSet rs = stmt.executeQuery(
+                                       "SELECT time_req, url FROM MissingInformation where isSend=0;");
+                    String urlUnreported = "";
+                    String time_req = "";
+
+                    HashMap<String, String> timestampURLMap = new HashMap<String, String>();
+
+                    if (!rs.isBeforeFirst())
+                        System.out.println("No pending missing requests");
+
+                    else {
+                        while (rs.next()) {
+                            time_req = rs.getString("time_req");
+                            urlUnreported = rs.getString("url");
+                            timestampURLMap.put(time_req, urlUnreported);
+                        }
+                    }
+
+                    for (Map.Entry<String, String> entry : timestampURLMap
+                            .entrySet()) {
+                        String timeStamp = entry.getKey();
+                        String urlForReport = entry.getValue();
+
+                        URL obj = new URL(urlForReport + "&cdt="
+                                          + URLEncoder.encode(timeStamp,
+                                                              StandardCharsets.UTF_8.name()));
+                        HttpURLConnection con = (HttpURLConnection) obj
+                                                .openConnection();
+                        int responseCode = con.getResponseCode();
+                        if (responseCode == 200) {
+                            String sqlUpdate = "";
+
+                            sqlUpdate = "UPDATE MissingInformation set isSend=1 where time_req='"
+                                        + timeStamp + "';";
+                            stmt.executeUpdate(sqlUpdate);
+                            System.out.println("Unreported Event sent");
+                        }
+                    }
+                } catch (Exception e) {
+                    System.out.println(e);
+                }
+            } else if (argument.equals("-delete")) {
+
+                String sqlPurge = "DELETE FROM MissingInformation where isSend=1;";
+                int deletedRowCount = stmt.executeUpdate(sqlPurge);
+                System.out.println(deletedRowCount
+                                   +  " missing requests have already been sent to Matomo and deleted from local DB");
+
+            }
+        } catch (Exception e) {
+            System.out.println("Error in creating table " + e.getMessage());
+        }
+    }
+}
\ No newline at end of file
diff --git a/dspace/modules/openaire-piwik/openaire-piwik-api/src/main/java/org/dspace/core/ConfigurationManager.java b/dspace/modules/openaire-piwik/openaire-piwik-api/src/main/java/org/dspace/core/ConfigurationManager.java
new file mode 100644
index 000000000..116313cef
--- /dev/null
+++ b/dspace/modules/openaire-piwik/openaire-piwik-api/src/main/java/org/dspace/core/ConfigurationManager.java
@@ -0,0 +1,1024 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.core;
+
+import org.apache.log4j.Category;
+import org.apache.log4j.Logger;
+import org.apache.log4j.helpers.OptionConverter;
+
+import java.io.*;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Properties;
+
+/**
+ * Class for reading the DSpace system configuration. The main configuration is
+ * read in as properties from a standard properties file. Email templates and
+ * configuration files for other tools are also be accessed via this class.
+ * <P>
+ * The main configuration is by default read from the <em>resource</em>
+ * <code>/dspace.cfg</code>.
+ * To specify a different configuration, the system property
+ * <code>dspace.configuration</code> should be set to the <em>filename</em>
+ * of the configuration file.
+ * <P>
+ * Other configuration files are read from the <code>config</code> directory
+ * of the DSpace installation directory (specified as the property
+ * <code>dspace.dir</code> in the main configuration file.)
+ *
+ *
+ * @author Robert Tansley
+ * @author Larry Stone - Interpolated values.
+ * @author Mark Diggory - General Improvements to detection, logging and loading.
+ * @version $Revision$
+ */
+public class ConfigurationManager
+{
+    /** log4j category */
+    private static Logger log = Logger.getLogger(ConfigurationManager.class);
+
+    /** The configuration properties */
+    private static Properties properties = null;
+
+    /** module configuration properties */
+    private static Map<String, Properties> moduleProps = new HashMap<String, Properties>();
+
+    // limit of recursive depth of property variable interpolation in
+    // configuration; anything greater than this is very likely to be a loop.
+    private static final int RECURSION_LIMIT = 9;
+
+    protected ConfigurationManager()
+    {
+
+    }
+
+    /**
+     * Identify if DSpace is properly configured
+     * @return boolean true if configured, false otherwise
+     */
+    public static boolean isConfigured()
+    {
+        return properties != null;
+    }
+
+    public static boolean isConfigured(String module)
+    {
+        return moduleProps.get(module) != null;
+    }
+
+    /**
+     * REMOVED - Flushing the properties could be dangerous in the current DSpace state
+     * Need to consider how it will affect in-flight processes
+     *
+     * Discard all current properties - will force a reload from disk when
+     * any properties are requested.
+     */
+//    public static void flush()
+//    {
+//        properties = null;
+//    }
+
+    /**
+     * REMOVED - Flushing the properties could be dangerous in the current DSpace state
+     * Need to consider how it will affect in-flight processes
+     *
+     * Discard properties for a module -  will force a reload from disk
+     * when any of module's properties are requested
+     *
+     * @param module the module name
+     */
+//    public static void flush(String module)
+//    {
+//        moduleProps.remove(module);
+//    }
+
+    /**
+     * Returns all properties in main configuration
+     *
+     * @return properties - all non-modular properties
+     */
+    public static Properties getProperties()
+    {
+        Properties props = getMutableProperties();
+        return props == null ? null : (Properties)props.clone();
+    }
+
+    private static Properties getMutableProperties()
+    {
+        if (properties == null)
+        {
+            loadConfig(null);
+        }
+
+        return properties;
+    }
+
+    /**
+     * Returns all properties for a given module
+     *
+     * @param module
+     *        the name of the module
+     * @return properties - all module's properties
+     */
+    public static Properties getProperties(String module)
+    {
+        Properties props = getMutableProperties(module);
+        return props == null ? null : (Properties)props.clone();
+    }
+
+    private static Properties getMutableProperties(String module)
+    {
+        if (module == null)
+            return properties;
+
+        if (moduleProps == null)
+        {
+            loadConfig(null);
+        }
+        Properties retProps = moduleProps.get(module);
+        if (retProps == null)
+        {
+            loadModuleConfig(module);
+            retProps = moduleProps.get(module);
+        }
+
+        return retProps;
+    }
+
+    /**
+     * Get a configuration property
+     *
+     * @param property
+     *            the name of the property
+     *
+     * @return the value of the property, or <code>null</code> if the property
+     *         does not exist.
+     */
+    public static String getProperty(String property)
+    {
+        Properties props = getMutableProperties();
+        String value = props == null ? null : props.getProperty(property);
+        return (value != null) ? value.trim() : null;
+    }
+
+    /**
+     * Get a module configuration property value.
+     *
+     * @param module
+     *      the name of the module, or <code>null</code> for regular configuration
+     *      property
+     * @param property
+     *      the name (key) of the property
+     * @return
+     *      the value of the property, or <code>null</code> if the
+     *      property does not exist
+     */
+    public static String getProperty(String module, String property)
+    {
+        if (module == null)
+        {
+            return getProperty(property);
+        }
+
+        String value = null;
+        Properties modProps = getMutableProperties(module);
+
+        if (modProps != null)
+        {
+            value = modProps.getProperty(property);
+        }
+
+        if (value == null)
+        {
+            // look in regular properties with module name prepended
+            value = getProperty(module + "." + property);
+        }
+
+        return (value != null) ? value.trim() : null;
+    }
+
+    /**
+     * Get a configuration property as an integer
+     *
+     * @param property
+     *            the name of the property
+     *
+     * @return the value of the property. <code>0</code> is returned if the
+     *         property does not exist. To differentiate between this case and
+     *         when the property actually is zero, use <code>getProperty</code>.
+     */
+    public static int getIntProperty(String property)
+    {
+        return getIntProperty(property, 0);
+    }
+
+    /**
+     * Get a module configuration property as an integer
+     *
+     * @param module
+     *         the name of the module
+     *
+     * @param property
+     *            the name of the property
+     *
+     * @return the value of the property. <code>0</code> is returned if the
+     *         property does not exist. To differentiate between this case and
+     *         when the property actually is zero, use <code>getProperty</code>.
+     */
+    public static int getIntProperty(String module, String property)
+    {
+        return getIntProperty(module, property, 0);
+    }
+
+    /**
+     * Get a configuration property as an integer, with default
+     *
+     * @param property
+     *            the name of the property
+     *
+     * @param defaultValue
+     *            value to return if property is not found or is not an Integer.
+     *
+     * @return the value of the property. <code>default</code> is returned if
+     *         the property does not exist or is not an Integer. To differentiate between this case
+     *         and when the property actually is false, use
+     *         <code>getProperty</code>.
+     */
+    public static int getIntProperty(String property, int defaultValue)
+    {
+        return getIntProperty(null, property, defaultValue);
+    }
+
+    /**
+     * Get a module configuration property as an integer, with default
+     *
+     * @param module
+     *         the name of the module
+     *
+     * @param property
+     *            the name of the property
+     *
+     * @param defaultValue
+     *            value to return if property is not found or is not an Integer.
+     *
+     * @return the value of the property. <code>default</code> is returned if
+     *         the property does not exist or is not an Integer. To differentiate between this case
+     *         and when the property actually is false, use
+     *         <code>getProperty</code>.
+     */
+    public static int getIntProperty(String module, String property, int defaultValue)
+    {
+       String stringValue = getProperty(module, property);
+       int intValue = defaultValue;
+
+       if (stringValue != null)
+       {
+           try
+           {
+               intValue = Integer.parseInt(stringValue.trim());
+           }
+           catch (NumberFormatException e)
+           {
+               warn("Warning: Number format error in property: " + property);
+           }
+        }
+
+        return intValue;
+    }
+
+    /**
+     * Get a configuration property as a long
+     *
+     * @param property
+     *            the name of the property
+     *
+     * @return the value of the property. <code>0</code> is returned if the
+     *         property does not exist. To differentiate between this case and
+     *         when the property actually is zero, use <code>getProperty</code>.
+     */
+    public static long getLongProperty(String property)
+    {
+        return getLongProperty(property, 0);
+    }
+
+    /**
+     * Get a module configuration property as a long
+     *
+     * @param module
+     *         the name of the module
+     * @param property
+     *            the name of the property
+     *
+     * @return the value of the property. <code>0</code> is returned if the
+     *         property does not exist. To differentiate between this case and
+     *         when the property actually is zero, use <code>getProperty</code>.
+     */
+    public static long getLongProperty(String module, String property)
+    {
+        return getLongProperty(module, property, 0);
+    }
+
+   /**
+     * Get a configuration property as an long, with default
+     *
+     *
+     * @param property
+     *            the name of the property
+     *
+     * @param defaultValue
+     *            value to return if property is not found or is not a Long.
+     *
+     * @return the value of the property. <code>default</code> is returned if
+     *         the property does not exist or is not an Integer. To differentiate between this case
+     *         and when the property actually is false, use
+     *         <code>getProperty</code>.
+     */
+    public static long getLongProperty(String property, int defaultValue)
+    {
+        return getLongProperty(null, property, defaultValue);
+    }
+
+    /**
+     * Get a configuration property as an long, with default
+     *
+     * @param module  the module, or <code>null</code> for regular property
+     *
+     * @param property
+     *            the name of the property
+     *
+     * @param defaultValue
+     *            value to return if property is not found or is not a Long.
+     *
+     * @return the value of the property. <code>default</code> is returned if
+     *         the property does not exist or is not an Integer. To differentiate between this case
+     *         and when the property actually is false, use
+     *         <code>getProperty</code>.
+     */
+    public static long getLongProperty(String module, String property, int defaultValue)
+    {
+        String stringValue = getProperty(module, property);
+        long longValue = defaultValue;
+
+        if (stringValue != null)
+        {
+            try
+            {
+                longValue = Long.parseLong(stringValue.trim());
+            }
+            catch (NumberFormatException e)
+            {
+                warn("Warning: Number format error in property: " + property);
+            }
+        }
+
+        return longValue;
+    }
+
+    /**
+     * Get a configuration property as a boolean. True is indicated if the value
+     * of the property is <code>TRUE</code> or <code>YES</code> (case
+     * insensitive.)
+     *
+     * @param property
+     *            the name of the property
+     *
+     * @return the value of the property. <code>false</code> is returned if
+     *         the property does not exist. To differentiate between this case
+     *         and when the property actually is false, use
+     *         <code>getProperty</code>.
+     */
+    public static boolean getBooleanProperty(String property)
+    {
+        return getBooleanProperty(property, false);
+    }
+
+    /**
+     * Get a module configuration property as a boolean. True is indicated if
+     * the value of the property is <code>TRUE</code> or <code>YES</code> (case
+     * insensitive.)
+     *
+     * @param module the module, or <code>null</code> for regular property
+     *
+     * @param property
+     *            the name of the property
+     *
+     * @return the value of the property. <code>false</code> is returned if
+     *         the property does not exist. To differentiate between this case
+     *         and when the property actually is false, use
+     *         <code>getProperty</code>.
+     */
+    public static boolean getBooleanProperty(String module, String property)
+    {
+        return getBooleanProperty(module, property, false);
+    }
+
+   /**
+     * Get a configuration property as a boolean, with default.
+     * True is indicated if the value
+     * of the property is <code>TRUE</code> or <code>YES</code> (case
+     * insensitive.)
+     *
+     * @param property
+     *            the name of the property
+     *
+     * @param defaultValue
+     *            value to return if property is not found.
+     *
+     * @return the value of the property. <code>default</code> is returned if
+     *         the property does not exist. To differentiate between this case
+     *         and when the property actually is false, use
+     *         <code>getProperty</code>.
+     */
+    public static boolean getBooleanProperty(String property, boolean defaultValue)
+    {
+        return getBooleanProperty(null, property, defaultValue);
+    }
+
+    /**
+     * Get a module configuration property as a boolean, with default.
+     * True is indicated if the value
+     * of the property is <code>TRUE</code> or <code>YES</code> (case
+     * insensitive.)
+     *
+     * @param module     module, or <code>null</code> for regular property
+     *
+     * @param property
+     *            the name of the property
+     *
+     * @param defaultValue
+     *            value to return if property is not found.
+     *
+     * @return the value of the property. <code>default</code> is returned if
+     *         the property does not exist. To differentiate between this case
+     *         and when the property actually is false, use
+     *         <code>getProperty</code>.
+     */
+    public static boolean getBooleanProperty(String module, String property, boolean defaultValue)
+    {
+        String stringValue = getProperty(module, property);
+
+        if (stringValue != null)
+        {
+        	stringValue = stringValue.trim();
+            return  stringValue.equalsIgnoreCase("true") ||
+                    stringValue.equalsIgnoreCase("yes");
+        }
+        else
+        {
+            return defaultValue;
+        }
+    }
+
+    /**
+     * Returns an enumeration of all the keys in the DSpace configuration
+     *
+     * @return an enumeration of all the keys in the DSpace configuration
+     */
+    public static Enumeration<?> propertyNames()
+    {
+        return propertyNames(null);
+    }
+
+    /**
+     * Returns an enumeration of all the keys in a module configuration
+     *
+     * @param  module    module, or <code>null</code> for regular property
+     *
+     * @return an enumeration of all the keys in the module configuration,
+     *         or <code>null</code> if the module does not exist.
+     */
+    public static Enumeration<?> propertyNames(String module)
+    {
+        Properties props = getProperties(module);
+        return props == null ? null : props.propertyNames();
+    }
+
+    /** The configuration that was loaded. */
+    private static File loadedFile = null;
+
+    /**
+     * Return the file that configuration was actually loaded from.
+     *
+     * @deprecated Please remove all direct usage of the configuration file.
+     * @return File naming configuration data file.
+     */
+    protected static File getConfigurationFile()
+    {
+        // in case it hasn't been done yet.
+        if (loadedFile == null)
+        {
+            loadConfig(null);
+        }
+
+        return loadedFile;
+    }
+
+    private static synchronized void loadModuleConfig(String module)
+    {
+        // try to find it in modules
+        File modFile = null;
+        try
+        {
+            modFile = new File(getProperty("dspace.dir") +
+                                File.separator + "config" +
+                                File.separator + "modules" +
+                                File.separator + module + ".cfg");
+
+            if (modFile.exists())
+            {
+                Properties modProps = new Properties();
+                InputStream modIS = null;
+                InputStreamReader modIR = null;
+                try
+                {
+                    modIS = new FileInputStream(modFile);
+                    modIR = new InputStreamReader(modIS, "UTF-8");
+                    modProps.load(modIR);
+                }
+                finally
+                {
+                    if (modIR != null)
+                    {
+                        modIR.close();
+                    }
+
+                    if (modIS != null)
+                    {
+                        modIS.close();
+                    }
+                }
+
+                for (Enumeration pe = modProps.propertyNames(); pe.hasMoreElements(); )
+                {
+                    String key = (String)pe.nextElement();
+                    String ival = interpolate(key, modProps.getProperty(key), 1);
+                    if (ival != null)
+                    {
+                        modProps.setProperty(key, ival);
+                    }
+                }
+                moduleProps.put(module, modProps);
+            }
+            else
+            {
+                // log invalid request
+                warn("Requested configuration module: " + module + " not found");
+            }
+        }
+        catch (IOException ioE)
+        {
+            fatal("Can't load configuration: " + (modFile == null ? "<unknown>" : modFile.getAbsolutePath()), ioE);
+        }
+    }
+
+    /**
+     * Load the DSpace configuration properties. Only does anything if
+     * properties are not already loaded. Properties are loaded in from the
+     * specified file, or default locations.
+     *
+     * @param configFile
+     *            The <code>dspace.cfg</code> configuration file to use, or
+     *            <code>null</code> to try default locations
+     */
+    public static synchronized void loadConfig(String configFile)
+    {
+        if (properties != null)
+        {
+            return;
+        }
+
+        URL url = null;
+
+        InputStream is = null;
+        InputStreamReader reader = null;
+        try
+        {
+            String configProperty = null;
+            try
+            {
+                configProperty = System.getProperty("dspace.configuration");
+            }
+            catch (SecurityException se)
+            {
+                // A security manager may stop us from accessing the system properties.
+                // This isn't really a fatal error though, so catch and ignore
+                log.warn("Unable to access system properties, ignoring.", se);
+            }
+
+            // should only occur after a flush()
+            if (loadedFile != null)
+            {
+                info("Reloading current config file: " + loadedFile.getAbsolutePath());
+
+                url = loadedFile.toURI().toURL();
+            }
+            else if (configFile != null)
+            {
+                info("Loading provided config file: " + configFile);
+
+                loadedFile = new File(configFile);
+                url = loadedFile.toURI().toURL();
+
+            }
+            // Has the default configuration location been overridden?
+            else if (configProperty != null)
+            {
+                info("Loading system provided config property (-Ddspace.configuration): " + configProperty);
+
+                // Load the overriding configuration
+                loadedFile = new File(configProperty);
+                url = loadedFile.toURI().toURL();
+            }
+            // Load configuration from default location
+            else
+            {
+                url = ConfigurationManager.class.getResource("/dspace.cfg");
+                if (url != null)
+                {
+                    info("Loading from classloader: " + url);
+
+                    loadedFile = new File(url.getPath());
+                }
+            }
+
+            if (url == null)
+            {
+                fatal("Cannot find dspace.cfg");
+                throw new IllegalStateException("Cannot find dspace.cfg");
+            }
+            else
+            {
+                properties = new Properties();
+                is = url.openStream();
+                reader = new InputStreamReader(is, "UTF-8");
+                properties.load(reader);
+
+                // walk values, interpolating any embedded references.
+                for (Enumeration<?> pe = properties.propertyNames(); pe.hasMoreElements(); )
+                {
+                    String key = (String)pe.nextElement();
+                    String value = interpolate(key, properties.getProperty(key), 1);
+                    if (value != null)
+                    {
+                        properties.setProperty(key, value);
+                    }
+                }
+            }
+
+        }
+        catch (IOException e)
+        {
+            fatal("Can't load configuration: " + url, e);
+
+            // FIXME: Maybe something more graceful here, but without a
+            // configuration we can't do anything.
+            throw new IllegalStateException("Cannot load configuration: " + url, e);
+        }
+        finally
+        {
+            if (reader != null)
+            {
+                try {
+                    reader.close();
+                }
+                catch (IOException ioe)
+                {
+                }
+            }
+            if (is != null)
+            {
+                try
+                {
+                    is.close();
+                }
+                catch (IOException ioe)
+                {
+                }
+            }
+        }
+
+        try
+        {
+            /*
+             * Initialize Logging once ConfigurationManager is initialized.
+             *
+             * This is controlled by a property in dspace.cfg.  If the property
+             * is absent then nothing will be configured and the application
+             * will use the defaults provided by log4j.
+             *
+             * Property format is:
+             *
+             * log.init.config = ${dspace.dir}/config/log4j.properties
+             * or
+             * log.init.config = ${dspace.dir}/config/log4j.xml
+             *
+             * See default log4j initialization documentation here:
+             * http://logging.apache.org/log4j/docs/manual.html
+             *
+             * If there is a problem with the file referred to in
+             * "log.configuration", it needs to be sent to System.err
+             * so do not instantiate another Logging configuration.
+             *
+             */
+            String dsLogConfiguration = ConfigurationManager.getProperty("log.init.config");
+
+            if (dsLogConfiguration == null || System.getProperty("dspace.log.init.disable") != null)
+            {
+                /*
+                 * Do nothing if log config not set in dspace.cfg or "dspace.log.init.disable"
+                 * system property set.  Leave it upto log4j to properly init its logging
+                 * via classpath or system properties.
+                 */
+                info("Using default log4j provided log configuration." +
+                        "  If unintended, check your dspace.cfg for (log.init.config)");
+            }
+            else
+            {
+                info("Using dspace provided log configuration (log.init.config)");
+
+
+                File logConfigFile = new File(dsLogConfiguration);
+
+                if(logConfigFile.exists())
+                {
+                    info("Loading: " + dsLogConfiguration);
+
+                    OptionConverter.selectAndConfigure(logConfigFile.toURI()
+                            .toURL(), null, org.apache.log4j.LogManager
+                            .getLoggerRepository());
+                }
+                else
+                {
+                    info("File does not exist: " + dsLogConfiguration);
+                }
+            }
+
+        }
+        catch (MalformedURLException e)
+        {
+            fatal("Can't load dspace provided log4j configuration", e);
+            throw new IllegalStateException("Cannot load dspace provided log4j configuration",e);
+        }
+
+    }
+
+    /**
+     * Wrapper for {@link NewsManager#getNewsFilePath()}.
+     * @deprecated since 4.0
+     */
+    public static String getNewsFilePath()
+    {
+        return NewsManager.getNewsFilePath();
+    }
+
+    /**
+     * Wrapper for {@link NewsManager#readNewsFile(String)}.
+     * @deprecated since 4.0
+     */
+    public static String readNewsFile(String name)
+    {
+        return NewsManager.readNewsFile(name);
+    }
+
+    /**
+     * Wrapper for {@link NewsManager#writeNewsFile(String, String)}.
+     * @deprecated since 4.0
+     */
+    public static String writeNewsFile(String file, String news)
+    {
+        return NewsManager.writeNewsFile(file, news);
+    }
+
+    /**
+     * Wrapper for {@link LicenseManager#getLicenseText(String)}.
+     * @deprecated since 4.0
+     */
+    public static String getLicenseText(String licenseFile)
+    {
+        return LicenseManager.getLicenseText(licenseFile);
+    }
+
+    /**
+     * Wrapper for {@link LicenseManager#getDefaultSubmissionLicense()}.
+     * @deprecated since 4.0
+     */
+    public static String getDefaultSubmissionLicense()
+    {
+        return LicenseManager.getDefaultSubmissionLicense();
+    }
+
+    /**
+     * Wrapper for {@link LicenseManager#writeLicenseFile(String, String)}.
+     * @deprecated since 4.0
+     */
+    public static void writeLicenseFile(String licenseFile, String newLicense)
+    {
+        LicenseManager.writeLicenseFile(licenseFile, newLicense);
+    }
+
+    /**
+     * Recursively interpolate variable references in value of
+     * property named "key".
+     * @return new value if it contains interpolations, or null
+     *   if it had no variable references.
+     */
+    private static String interpolate(String key, String value, int level)
+    {
+        if (level > RECURSION_LIMIT)
+        {
+            throw new IllegalArgumentException("ConfigurationManager: Too many levels of recursion in configuration property variable interpolation, property=" + key);
+        }
+        //String value = (String)properties.get(key);
+        int from = 0;
+        StringBuffer result = null;
+        while (from < value.length())
+        {
+            int start = value.indexOf("${", from);
+            if (start >= 0)
+            {
+                int end = value.indexOf('}', start);
+                if (end < 0)
+                {
+                    break;
+                }
+                String var = value.substring(start+2, end);
+                if (result == null)
+                {
+                    result = new StringBuffer(value.substring(from, start));
+                }
+                else
+                {
+                    result.append(value.substring(from, start));
+                }
+                if (properties.containsKey(var))
+                {
+                    String ivalue = interpolate(var, properties.getProperty(var), level+1);
+                    if (ivalue != null)
+                    {
+                        result.append(ivalue);
+                        properties.setProperty(var, ivalue);
+                    }
+                    else
+                    {
+                        result.append(((String)properties.getProperty(var)).trim());
+                    }
+                }
+                else
+                {
+                    log.warn("Interpolation failed in value of property \""+key+
+                             "\", there is no property named \""+var+"\"");
+                }
+                from = end+1;
+            }
+            else
+            {
+                break;
+            }
+        }
+        if (result != null && from < value.length())
+        {
+            result.append(value.substring(from));
+        }
+        return (result == null) ? null : result.toString();
+    }
+
+    /**
+     * Command-line interface for running configuration tasks. Possible
+     * arguments:
+     * <ul>
+     * <li><code>-property name</code> prints the value of the property
+     * <code>name</code> from <code>dspace.cfg</code> to the standard
+     * output. If the property does not exist, nothing is written.</li>
+     * </ul>
+     *
+     * @param argv
+     *            command-line arguments
+     */
+    public static void main(String[] argv)
+    {
+        if ((argv.length == 2) && argv[0].equals("-property"))
+        {
+            String val = getProperty(argv[1]);
+
+            if (val != null)
+            {
+                System.out.println(val);
+            }
+            else
+            {
+                System.out.println("");
+            }
+
+            System.exit(0);
+        }
+        else if ((argv.length == 4) && argv[0].equals("-module") &&
+                                        argv[2].equals("-property"))
+        {
+            String val = getProperty(argv[1], argv[3]);
+
+            if (val != null)
+            {
+                System.out.println(val);
+            }
+            else
+            {
+                System.out.println("");
+            }
+
+            System.exit(0);
+        }
+        else
+        {
+            System.err
+                    .println("Usage: ConfigurationManager OPTION\n  [-module mod.name] -property prop.name  get value of prop.name from module or dspace.cfg");
+        }
+
+        System.exit(1);
+    }
+
+    private static void info(String string)
+    {
+        if (!isLog4jConfigured())
+        {
+            System.out.println("INFO: " + string);
+        }
+        else
+        {
+            log.info(string);
+        }
+    }
+
+    private static void warn(String string)
+    {
+        if (!isLog4jConfigured())
+        {
+            System.out.println("WARN: " + string);
+        }
+        else
+        {
+            log.warn(string);
+        }
+    }
+
+    private static void fatal(String string, Exception e)
+    {
+        if (!isLog4jConfigured())
+        {
+            System.out.println("FATAL: " + string);
+            e.printStackTrace();
+        }
+        else
+        {
+            log.fatal(string, e);
+        }
+    }
+
+    private static void fatal(String string)
+    {
+        if (!isLog4jConfigured())
+        {
+            System.out.println("FATAL: " + string);
+        }
+        else
+        {
+            log.fatal(string);
+        }
+    }
+
+    /*
+     * Only current solution available to detect
+     * if log4j is truly configured.
+     */
+    private static boolean isLog4jConfigured()
+    {
+        Enumeration<?> en = org.apache.log4j.LogManager.getRootLogger()
+                .getAllAppenders();
+
+        if (!(en instanceof org.apache.log4j.helpers.NullEnumeration))
+        {
+            return true;
+        }
+        else
+        {
+            Enumeration<?> cats = Category.getCurrentCategories();
+            while (cats.hasMoreElements())
+            {
+                Category c = (Category) cats.nextElement();
+                if (!(c.getAllAppenders() instanceof org.apache.log4j.helpers.NullEnumeration))
+                {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+}
diff --git a/dspace/modules/openaire-piwik/pom.xml b/dspace/modules/openaire-piwik/pom.xml
new file mode 100755
index 000000000..190ab73cd
--- /dev/null
+++ b/dspace/modules/openaire-piwik/pom.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <groupId>com.openaire</groupId>
+    <artifactId>openaire-piwik</artifactId>
+    <packaging>pom</packaging>
+    <url>openaire.eu</url>
+    <name>OpenAIRE Piwik tracker</name>
+    <version>1.0.0</version>
+
+   <parent>
+        <groupId>org.dspace</groupId>
+        <artifactId>modules</artifactId>
+        <version>[4.0,4.*]</version>
+    </parent>
+
+    <modules>
+        <module>openaire-piwik-api</module>
+    </modules>
+
+</project>
diff --git a/dspace/modules/pom.xml b/dspace/modules/pom.xml
index 104d02bca..bf00c3d3c 100644
--- a/dspace/modules/pom.xml
+++ b/dspace/modules/pom.xml
@@ -22,6 +22,7 @@
          as a dependency in most other modules in [src]/dspace/modules -->
     <modules>
         <module>additions</module>
+       <module>openaire-piwik</module>        
     </modules>
 
     <!-- 
diff --git a/dspace/modules/xmlui/pom.xml b/dspace/modules/xmlui/pom.xml
index 4bb22d5fe..6fe3641e6 100644
--- a/dspace/modules/xmlui/pom.xml
+++ b/dspace/modules/xmlui/pom.xml
@@ -99,7 +99,13 @@
          <groupId>org.dspace.modules</groupId>
          <artifactId>additions</artifactId>
       </dependency>
-
+       <!-- OpenAire Piwik Tracker  -->
+        <dependency>
+            <groupId>com.openaire</groupId>
+            <artifactId>openaire-piwik-api</artifactId>
+            <version>1.0.0</version>
+            <type>jar</type>
+        </dependency>
       <!-- DSpace XMLUI Languages -->
       <dependency>
          <groupId>org.dspace</groupId>
